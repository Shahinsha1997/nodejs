interface TursoConfig {
    org: string;
    token: string;
    baseUrl?: string;
}

interface ApiToken {
    id: string;
    name: string;
}
interface ApiTokenWithJWT extends ApiToken {
    token: string;
}
interface RevokedApiToken {
    token: string;
}
interface ApiTokenValidation {
    valid: boolean;
    expiry: number;
}
declare class ApiTokenClient {
    private config;
    constructor(config: TursoConfig);
    list(): Promise<ApiToken[]>;
    create(name: string): Promise<ApiTokenWithJWT>;
    revoke(name: string): Promise<RevokedApiToken>;
    validate(token: string): Promise<ApiTokenValidation>;
}

interface Organization {
    name: string;
    slug: string;
    type: "personal" | "team";
    overages: boolean;
    blocked_reads: boolean;
    blocked_writes: boolean;
}
interface OrganizationMember {
    role: "owner" | "admin" | "member";
    username: string;
    email: string;
}
interface OrganizationInvite {
    ID: number;
    CreatedAt: string;
    UpdatedAt: string;
    DeletedAt: string;
    Role: "admin" | "member";
    Email: string;
    OrganizationID: number;
    Organization: Organization;
    Accepted: boolean;
}
interface Invoice {
    invoice_number: string;
    amount_due: string;
    due_date: string;
    paid_at: string;
    payment_failed_at: string;
    invoice_pdf: string;
}
type OrganizationMemberRole = "admin" | "member";
interface OrganizationAddedMember {
    member: string;
    role: OrganizationMemberRole;
}
interface OrganizationRemovedMember {
    member: string;
}
declare class OrganizationClient {
    private config;
    constructor(config: TursoConfig);
    list(): Promise<Organization[]>;
    update(options: {
        overages: boolean;
    }): Promise<Organization>;
    delete(): Promise<void>;
    members(): Promise<OrganizationMember[]>;
    addMember(username: string, role?: "admin" | "member"): Promise<OrganizationAddedMember>;
    removeMember(username: string): Promise<OrganizationRemovedMember>;
    inviteUser(email: string, role?: OrganizationMemberRole): Promise<OrganizationInvite>;
    deleteInvite(email: string): Promise<OrganizationInvite>;
    invoices(): Promise<Invoice[]>;
}

type LocationKeys = {
    ams: string;
    arn: string;
    bog: string;
    bos: string;
    cdg: string;
    den: string;
    dfw: string;
    ewr: string;
    fra: string;
    gdl: string;
    gig: string;
    gru: string;
    hkg: string;
    iad: string;
    jnb: string;
    lax: string;
    lhr: string;
    mad: string;
    mia: string;
    nrt: string;
    ord: string;
    otp: string;
    qro: string;
    scl: string;
    sea: string;
    sin: string;
    sjc: string;
    syd: string;
    waw: string;
    yul: string;
    yyz: string;
    [key: string]: string;
};
type Location = {
    [K in keyof LocationKeys]: {
        code: K;
        description: LocationKeys[K];
    };
}[keyof LocationKeys];
interface ClosestLocation {
    server: keyof LocationKeys;
    client: keyof LocationKeys;
}
declare class LocationClient {
    private config;
    constructor(config: TursoConfig);
    list(): Promise<Location[]>;
    closest(): Promise<ClosestLocation>;
}

interface Database {
    name: string;
    id: string;
    hostname: string;
    regions?: Array<keyof LocationKeys>;
    primaryRegion?: keyof LocationKeys;
    type: string;
    version: string;
    group?: string;
    sleeping: boolean;
    allow_attach: boolean;
    block_reads: boolean;
    block_writes: boolean;
    schema?: string;
    is_schema: boolean;
}
interface CreatedDatabase {
    name: string;
    id: string;
    hostname: string;
}
interface DatabaseInstanceUsageDetail {
    rows_read: number;
    rows_written: number;
    storage_bytes: number;
}
interface DatabaseInstanceUsage {
    uuid: string;
    usage: DatabaseInstanceUsageDetail;
}
interface DatabaseUsage {
    uuid: string;
    instances: DatabaseInstanceUsage[];
    usage: DatabaseInstanceUsageDetail;
}
interface InstanceUsages {
    [instanceUuid: string]: DatabaseInstanceUsageDetail;
}
interface TotalUsage {
    rows_read: number;
    rows_written: number;
    storage_bytes: number;
}
interface DatabaseInstance {
    uuid: string;
    name: keyof LocationKeys;
    type: "primary" | "replica";
    region: keyof LocationKeys;
    hostname: string;
}
interface DeletedDatabase {
    database: string;
}
interface DatabaseToken {
    jwt: string;
}
type MultiDBSchemaOptions = {
    is_schema: boolean;
    schema?: never;
} | {
    is_schema?: never;
    schema: string;
} | {};
declare class DatabaseClient {
    private config;
    constructor(config: TursoConfig);
    list(): Promise<Database[]>;
    get(dbName: string): Promise<Database>;
    create(dbName: string, options?: {
        image?: "latest" | "canary";
        group?: string;
        seed?: {
            type: "database" | "dump";
            name?: string;
            url?: string;
            timestamp?: string | Date;
        };
    } & MultiDBSchemaOptions): Promise<CreatedDatabase>;
    updateVersion(dbName: string): Promise<void>;
    delete(dbName: string): Promise<DeletedDatabase>;
    listInstances(dbName: string): Promise<DatabaseInstance[]>;
    getInstance(dbName: string, instanceName: keyof LocationKeys): Promise<DatabaseInstance>;
    createToken(dbName: string, options?: {
        expiration?: string;
        authorization?: "read-only" | "full-access";
        permissions?: {
            read_attach: {
                databases: Database["name"][];
            };
        };
    }): Promise<DatabaseToken>;
    rotateTokens(dbName: string): Promise<void>;
    usage(dbName: string, options?: {
        from?: Date | string;
        to?: Date | string;
    }): Promise<DatabaseUsage>;
    private formatDateParameter;
    private formatResponse;
    private formatCreateResponse;
}

interface Group {
    locations: Array<keyof LocationKeys>;
    name: string;
    primary: keyof LocationKeys;
}
type ExtensionType = "vector" | "vss" | "crypto" | "fuzzy" | "math" | "stats" | "text" | "unicode" | "uuid" | "regexp";
interface GroupToken {
    jwt: string;
}
declare class GroupClient {
    private config;
    constructor(config: TursoConfig);
    list(): Promise<Group[]>;
    get(name: string): Promise<Group>;
    create(name: string, location: keyof LocationKeys, options?: {
        extensions?: Array<ExtensionType> | "all";
    }): Promise<Group>;
    delete(name: string): Promise<Group>;
    addLocation(groupName: string, location: keyof LocationKeys): Promise<Group>;
    removeLocation(groupName: string, location: keyof LocationKeys): Promise<Group>;
    createToken(groupName: string, options?: {
        expiration?: string;
        authorization?: "read-only" | "full-access";
        permissions?: {
            read_attach: {
                databases: Database["name"][];
            };
        };
    }): Promise<GroupToken>;
    rotateTokens(groupName: string): Promise<void>;
}

interface AdditionalInfo {
    status?: number;
}
declare class TursoClientError extends Error {
    status?: number;
    constructor(message: string, additionalInfo?: AdditionalInfo);
}
declare class TursoClient {
    private config;
    apiTokens: ApiTokenClient;
    organizations: OrganizationClient;
    locations: LocationClient;
    groups: GroupClient;
    databases: DatabaseClient;
    constructor(config: TursoConfig);
    static request<T>(url: string, config: TursoConfig, options?: RequestInit): Promise<T>;
}
declare function createClient(config: TursoConfig): TursoClient;

export { type ApiToken, type ApiTokenValidation, type ApiTokenWithJWT, type ClosestLocation, type CreatedDatabase, type Database, type DatabaseInstance, type DatabaseToken, type DatabaseUsage, type DeletedDatabase, type ExtensionType, type Group, type GroupToken, type InstanceUsages, type Invoice, type Location, type LocationKeys, type Organization, type OrganizationAddedMember, type OrganizationInvite, type OrganizationMember, type OrganizationMemberRole, type OrganizationRemovedMember, type RevokedApiToken, type TotalUsage, TursoClientError, type TursoConfig, createClient };
